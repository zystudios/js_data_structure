/*
91. 解码方法
一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> 1
'B' -> 2
...
'Z' -> 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。


*/

/*

这个题可以简化一下，不用管映射字母

其实就是一个数字，按照顺序从前往后，可以分割为多少个可能
1 最小的是1，没有0
2 最大的是26，超过就不行，比如27就必须拆成2和7
3 个位数不能是0开头



*/

/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function (s) {
    var n = s.length;
    if (s[0] == '0') {
        return 0;
    }
   // 规定了0不能开头，开头就说明这个字符串无效
    var dp = Array(n).fill(0);

    // 先建一个数组，0填充 长度等于字符串长度
    // 这个数组意思保存当前位置以前，可以拆分的数量

    dp[0] = 1;
    // 如果开头不是0,那么肯定至少有一个解，所以第一个先给1


    // 先看看前两位情况
        if (n > 1) {
            //如果字符串长度大于1
            var s_temp = s[0] + s[1];
            //先取前两个
            s_temp = +s_temp;
            //转换为数字，如果这个数字大于26了，余数为0 表示是30，40，50这种了，那么如果分解
            //就会分解出一个0开头的个位数，就肯定不对了，30分解为3，0 按规定，0不能开头，这个两位数又
            //超过26，所以不对
            if (s_temp > 20 && s_temp % 10 == 0) {
                return 0;
            }

            //如果这个数字小于等于26，且有余数，说明不会分解为0开头的数

            if (s_temp <= 26 && s_temp % 10 != 0) {
                // 小于26的数字，且余数不为0，排除10，20.可以拆两个情况
                dp[1] = 2;
            } else {
                // 否则，只能拆1个情况
                dp[1] = 1;
            }
        }

   // 遍历字符串,其实就是吧这个数，和他前面一个，再前面一个比较，看能不能拆
    for (i = 2; i < n; i++) {
        if (s[i] != '0') {
            // 某个数字不=0 看他前面的是不是等于1
            if (s[i - 1] == '1') {
                // 他前面的等于1,表示可以拆2个情况，一个是1位数，一个是2位数
                //dp[i]这里就记录下他前面已经拆的数量和
                dp[i] = dp[i - 1] + dp[i - 2];
            } else if (s[i - 1] == '2') {
                //如果前面的==2，那么要看，他自己是不是小于等于6
                if (s[i] <= '6') {
                   // 如果是，就表示可以拆两种，一个是一位数，一个是2位数
                    dp[i] = dp[i - 1] + dp[i - 2];
                } else {
                    //如果不是，就要单独拆
                    dp[i] = dp[i - 1];
                }
            } else {
                dp[i] = dp[i - 1];
            }
        } else {
            //如果某一个数字是0，看他前面的数是0还是大于2，如果前面是0，那就是00，不对
            //如果大于2，说明就是30，40，50这样的，没法拆了，也不对
            if (s[i - 1] == '0' || s[i - 1] > '2') {
                return 0;
            } else {
                
                //不满足上面，说明可以拆
                dp[i] = dp[i - 2];
            }
        }
    }
    return dp[n - 1];
};



console.log(numDecodings('1221'));
